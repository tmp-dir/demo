## What we care about
1. core logic -> see below
2. interface. This just provides a `get_rate` method, taking in a unix ts. Arguably could extend this to just return the theo, however for now it returns the rate.
3. edge cases. See test suite. invalidates for not enough futures, does not care about ordering. Though this is because i'm not doing anything like spline fitting.

## core logic

approaching this with exponential compounding and lin reg. representing a future as $F=Se^{-rT} \implies \frac{\log{\frac{S}{F}}}{T} = r$. this should basically pull it into a linear space. justification here is that the term structure for available crypto futures are basically 1 week to 6 months

I'm making assumptions about the data being pulled in as well. calculating instantaneous rates off of a nebulous price. almost certainly going to want some better feed in here, some depth weighted pricing or averaged through time or both. Also there's no real expiry conditions, ripping out an implied rate close to expiry will cause the implied rate to become huge. 

Similarly no adj for exchange to exchange, there's likely going to be systematic adjustments that need to be made between exchanges to properly handle the differences.

I'm also not touching stables. since some futures are coming in with a different base, would want to go ahead convert the incoming price to have adjusted to some common stable.

I'm not doing any regularisation or anything, so one junk value generated by above can seriously start to warp the results.

also trying to keep this fast which is probably not that relevant if the primary usecase is some slow-loop system. it can just churn out a surface on request then.

doing some lin reg stuff. optimised for the `get_rate` call. probably not the correct optimisation since no. update calls will likely be much higher than the get_rate call count.

did this by splitting up into some $s_x$, $s_y$, $s_{xx}$, $s_{xy}$ and on demand ripping out the coeff from these bits in the `get_coeff` fn of the model class. issues here are that spot price and tte are used in the calculations and they will change independently. Going to assume that T is approx const, with sufficient updates to the future, this should be fine.

to handle the spot updates, I can split out the necessary params further and just compute the spot part when the rate is requested. Math here (F= future, S = spot, T = tte, r= implied rate):


$$s_x = \Sigma T_i$$
$$s_y = \Sigma r_i = \Sigma [\frac{\log{S}}{T_i} - \frac{\log{F_i}}{T_i}]$$
$$ = \log{S} \Sigma \frac{1}{T_i} - \Sigma \frac{F_i}{T_i} $$

so can just track the T_i and F_i / T_i sum and reconstitute.

$$s_xx = \Sigma T_i^2$$

$$s_xy = \Sigma r_i T_i = \Sigma [ \log{S} - \log{F_i} ] = n \log{S} - \Sigma \log{F_i} $$

so here just need to track the sum of the log futures.

## Usage

this will probably get it compiling, if fetch is installed.

    mkdir build && cd build && cmake ..
    cmake --build . && ./YieldCurve_Tests
    cmake --build . && .src/YieldCurve

otherwise check out main.cpp && model.hpp.
